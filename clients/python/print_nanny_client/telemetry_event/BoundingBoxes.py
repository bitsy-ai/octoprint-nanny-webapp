# automatically generated by the FlatBuffers compiler, do not modify

# namespace: telemetry_event

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class BoundingBoxes(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAsBoundingBoxes(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BoundingBoxes()
        x.Init(buf, n + offset)
        return x

    # BoundingBoxes
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BoundingBoxes
    def DetectionScores(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # BoundingBoxes
    def DetectionScoresAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # BoundingBoxes
    def DetectionScoresLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BoundingBoxes
    def DetectionScoresIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # BoundingBoxes
    def DetectionClasses(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # BoundingBoxes
    def DetectionClassesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # BoundingBoxes
    def DetectionClassesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BoundingBoxes
    def DetectionClassesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # BoundingBoxes
    def DetectionBoxes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 16
            from print_nanny_client.telemetry_event.Box import Box
            obj = Box()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BoundingBoxes
    def DetectionBoxesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BoundingBoxes
    def DetectionBoxesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # BoundingBoxes
    def NumDetections(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def BoundingBoxesStart(builder): builder.StartObject(4)
def BoundingBoxesAddDetectionScores(builder, detectionScores): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(detectionScores), 0)
def BoundingBoxesStartDetectionScoresVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def BoundingBoxesAddDetectionClasses(builder, detectionClasses): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(detectionClasses), 0)
def BoundingBoxesStartDetectionClassesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def BoundingBoxesAddDetectionBoxes(builder, detectionBoxes): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(detectionBoxes), 0)
def BoundingBoxesStartDetectionBoxesVector(builder, numElems): return builder.StartVector(16, numElems, 4)
def BoundingBoxesAddNumDetections(builder, numDetections): builder.PrependUint32Slot(3, numDetections, 0)
def BoundingBoxesEnd(builder): return builder.EndObject()

import print_nanny_client.telemetry_event.Box
try:
    from typing import List
except:
    pass

class BoundingBoxesT(object):

    # BoundingBoxesT
    def __init__(self):
        self.detectionScores = None  # type: List[float]
        self.detectionClasses = None  # type: List[int]
        self.detectionBoxes = None  # type: List[print_nanny_client.telemetry_event.Box.BoxT]
        self.numDetections = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        boundingBoxes = BoundingBoxes()
        boundingBoxes.Init(buf, pos)
        return cls.InitFromObj(boundingBoxes)

    @classmethod
    def InitFromObj(cls, boundingBoxes):
        x = BoundingBoxesT()
        x._UnPack(boundingBoxes)
        return x

    # BoundingBoxesT
    def _UnPack(self, boundingBoxes):
        if boundingBoxes is None:
            return
        if not boundingBoxes.DetectionScoresIsNone():
            if np is None:
                self.detectionScores = []
                for i in range(boundingBoxes.DetectionScoresLength()):
                    self.detectionScores.append(boundingBoxes.DetectionScores(i))
            else:
                self.detectionScores = boundingBoxes.DetectionScoresAsNumpy()
        if not boundingBoxes.DetectionClassesIsNone():
            if np is None:
                self.detectionClasses = []
                for i in range(boundingBoxes.DetectionClassesLength()):
                    self.detectionClasses.append(boundingBoxes.DetectionClasses(i))
            else:
                self.detectionClasses = boundingBoxes.DetectionClassesAsNumpy()
        if not boundingBoxes.DetectionBoxesIsNone():
            self.detectionBoxes = []
            for i in range(boundingBoxes.DetectionBoxesLength()):
                if boundingBoxes.DetectionBoxes(i) is None:
                    self.detectionBoxes.append(None)
                else:
                    box_ = print_nanny_client.telemetry_event.Box.BoxT.InitFromObj(boundingBoxes.DetectionBoxes(i))
                    self.detectionBoxes.append(box_)
        self.numDetections = boundingBoxes.NumDetections()

    # BoundingBoxesT
    def Pack(self, builder):
        if self.detectionScores is not None:
            if np is not None and type(self.detectionScores) is np.ndarray:
                detectionScores = builder.CreateNumpyVector(self.detectionScores)
            else:
                BoundingBoxesStartDetectionScoresVector(builder, len(self.detectionScores))
                for i in reversed(range(len(self.detectionScores))):
                    builder.PrependFloat32(self.detectionScores[i])
                detectionScores = builder.EndVector(len(self.detectionScores))
        if self.detectionClasses is not None:
            if np is not None and type(self.detectionClasses) is np.ndarray:
                detectionClasses = builder.CreateNumpyVector(self.detectionClasses)
            else:
                BoundingBoxesStartDetectionClassesVector(builder, len(self.detectionClasses))
                for i in reversed(range(len(self.detectionClasses))):
                    builder.PrependUint32(self.detectionClasses[i])
                detectionClasses = builder.EndVector(len(self.detectionClasses))
        if self.detectionBoxes is not None:
            BoundingBoxesStartDetectionBoxesVector(builder, len(self.detectionBoxes))
            for i in reversed(range(len(self.detectionBoxes))):
                self.detectionBoxes[i].Pack(builder)
            detectionBoxes = builder.EndVector(len(self.detectionBoxes))
        BoundingBoxesStart(builder)
        if self.detectionScores is not None:
            BoundingBoxesAddDetectionScores(builder, detectionScores)
        if self.detectionClasses is not None:
            BoundingBoxesAddDetectionClasses(builder, detectionClasses)
        if self.detectionBoxes is not None:
            BoundingBoxesAddDetectionBoxes(builder, detectionBoxes)
        BoundingBoxesAddNumDetections(builder, self.numDetections)
        boundingBoxes = BoundingBoxesEnd(builder)
        return boundingBoxes
